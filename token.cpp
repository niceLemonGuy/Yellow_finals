#include "token.h"

#include <stdexcept>

using namespace std;

// Функция занимается делением строки из потока на кусоки "токены", с которыми удобно работать дальше
vector<Token> Tokenize(istream& cl) {
  vector<Token> tokens; // Создаём вектор токенов для хранения распаршеного потока "строка - тип"

  char c; // Создаём символьную переменную для посимвольного считывания
  while (cl >> c) { // Считываем символы в цикле, пока поток не вернёт конец
    if (isdigit(c)) { // Проверка на цифру. Если да, то работаем с датой
      string date(1, c); // Создание строки из одного считанного символа, для набора символов для токена
      for (int i = 0; i < 3; ++i) { // Дата разделена на три части
        while (isdigit(cl.peek())) { // Пока следующий символ цифра - продолжаем
          date += cl.get(); // Считываем из потока символ и добавляем в строку
        }
        if (i < 2) { // Если не третья часть даты, то заходем
          date += cl.get(); // Добавляем стмвол '-'
        }
      }
      tokens.push_back({date, TokenType::DATE}); // Добавляем в вектор токенов строку и тип токена
    } else if (c == '"') { // Если считанный символ равен '"', значит это пример события для поиска
      string event; // Создаём строку под считывание из потока
      getline(cl, event, '"'); // Считываем из потока всё до слудующего символа '"'
      tokens.push_back({event, TokenType::EVENT}); // Добавляем в вектор токенов строку и тип токена
    } else if (c == 'd') { // Если считанный символ равен "d", значит это слово "date"
      if (cl.get() == 'a' && cl.get() == 't' && cl.get() == 'e') { // Считывание и проверка остальных букв в слове "date"
        tokens.push_back({"date", TokenType::COLUMN}); // Добавляем в вектор токенов строку и тип токена
      } else { // Иначе в поток затесалоть некорректное выражение
        throw logic_error("Unknown token"); // Кинуть исключение
      }
    } else if (c == 'e') { // Если считанный символ равен "e", значит это слово "event"
      if (cl.get() == 'v' && cl.get() == 'e' && cl.get() == 'n' &&
          cl.get() == 't') { // Считывание и проверка остальных букв в слове "event"
        tokens.push_back({"event", TokenType::COLUMN}); // Добавляем в вектор токенов строку и тип токена
      } else { // Иначе в поток затесалоть некорректное выражение
        throw logic_error("Unknown token"); // Кинуть исключение
      }
    } else if (c == 'A') { // Если считанный символ равен "A", значит это слово "AND"
      if (cl.get() == 'N' && cl.get() == 'D') { // Считывание и проверка остальных букв в слове "AND"
        tokens.push_back({"AND", TokenType::LOGICAL_OP}); // Добавляем в вектор токенов строку и тип токена
      } else { // Иначе в поток затесалоть некорректное выражение
        throw logic_error("Unknown token"); // Кинуть исключение
      }
    } else if (c == 'O') { // Если считанный символ равен "O", значит это слово "OR"
      if (cl.get() == 'R') { // Считывание и проверка остальных букв в слове "OR"
        tokens.push_back({"OR", TokenType::LOGICAL_OP}); // Добавляем в вектор токенов строку и тип токена
      } else { // Иначе в поток затесалоть некорректное выражение
        throw logic_error("Unknown token"); // Кинуть исключение
      }
    } else if (c == '(') { // Если считанный символ равен "(", значит начало выражения
      tokens.push_back({"(", TokenType::PAREN_LEFT}); // Добавляем в вектор токенов строку и тип токена
    } else if (c == ')') { // Если считанный символ равен "(", значит конец выражения
      tokens.push_back({")", TokenType::PAREN_RIGHT}); // Добавляем в вектор токенов строку и тип токена
    } else if (c == '<') { // Если считанный символ равен "<"
      if (cl.peek() == '=') { // Проверяем следующий символ, вдруг это оператор "<="
        cl.get(); // Считываем символ
        tokens.push_back({"<=", TokenType::COMPARE_OP}); // Добавляем "<="
      } else {
        tokens.push_back({"<", TokenType::COMPARE_OP}); // Добавляем "<"
      }
    } else if (c == '>') { // Если считанный символ равен ">"
      if (cl.peek() == '=') { // Проверяем следующий символ, вдруг это оператор ">="
        cl.get(); // Считываем символ
        tokens.push_back({">=", TokenType::COMPARE_OP}); // Добавляем ">="
      } else {
        tokens.push_back({">", TokenType::COMPARE_OP}); // Добавляем ">"
      }
    } else if (c == '=') { // Если считанный символ равен "="
      if (cl.get() == '=') { // Проверяем следующий символ, вдруг это оператор "=="
        tokens.push_back({"==", TokenType::COMPARE_OP}); // Добавляем "=="
      } else {
        throw logic_error("Unknown token");
      }
    } else if (c == '!') {
      if (cl.get() == '=') {
        tokens.push_back({"!=", TokenType::COMPARE_OP});
      } else { // Иначе в поток затесалоть некорректное выражение
        throw logic_error("Unknown token"); // Кинуть исключениеs
      }
    }
  }

  return tokens;
}
